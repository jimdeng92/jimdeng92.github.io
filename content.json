{"pages":[{"title":"","text":"📚 Blog这是一个兼具博客文章、知识管理、文档查找的个人网站，主要内容是Web前端技术。如果你喜欢这个博客，欢迎到GitHub点个Star。 ( •̀ ω •́ )✧ 🎨 Theme本站主题使用的是 hexo-theme-icarus，这是一款非常优秀的 hexo 主题，感谢作者的开源。 联系我 Email: jimdeng92@gmail.com GitHub: https://github.com/jimdeng92","link":"/about/index.html"}],"posts":[{"title":"Git生成多个秘钥","text":"需求背景：我有一个 github 账户用来维护个人的博客，公司用的是 gitlab ，两个账号的邮箱不同，无法公用一个公钥文件。因此得创建多个公钥不会导致项目的 git 冲突。 创建文件进入文件夹：cd ~/.ssh，生成 ssh key：ssh-keygen -t rsa -C &quot;your_email@example.com&quot;。 输入该命令后有连续的三个提示输入，第一个是你要创建的 ssh key 的文件名。我们就是通过第一个命令来创建不同的秘钥文件（如果不指定文件名会自动覆盖）。第二和第三次输入为秘钥口令，一般不填，直接回车。 这里我设置公司的公钥文件名为 id_rsa（默认文件名） ，自己的公钥文件名为 id_rsa_linhe_github 。这样就会根据公司邮箱和个人邮箱生成对应文件。 配置找到 key 所在的地方（我习惯用 everything 直接搜本地磁盘），创建 config 文件（无后缀），添加以下内容： 1234Host github.comIdentityFile ~/.ssh/id_rsa_linhe_githubUser your_email@example.com# 多个公钥可在后面继续添加其他配置 注意默认的 id_rsa 不需要配置。 字段 说明 Host 远程主机地址 IdentityFile 私钥的文件路径及文件名称 User 用户 Port 远程主机上连接的端口号 HostName 要登录的真实主机名。数字IP地址也是允许的 复制公钥到服务器打开 github 或 gitlab 的设置，找到 SSH keys 配置项，然后将公钥文件中的内容复制到这里就 ok 了。 其他一般来说，一台电脑要同时处理不用的 git 服务器，我们会使用不用的用户名。所以除了在初始化 git 时通过以下配置生成全局用户名和邮箱外，可能也需要在私有项目下配置项目下的用户名和邮箱，使用类似下面的命令，只是省略 --global 就可以了。 12$ git config --global user.name &quot;John Doe&quot;$ git config --global user.email johndoe@example.com","link":"/2020/10/11/Git%E7%94%9F%E6%88%90%E5%A4%9A%E4%B8%AA%E7%A7%98%E9%92%A5/"},{"title":"Icarus写作文档","text":"更多参考：Bulma文档 提示信息展现需要关注的信息 基本用法 Message >folded12345&lt;article class=&quot;message&quot;&gt; &lt;div class=&quot;message-body&quot;&gt; Message &lt;/div&gt;&lt;/article&gt; 尺寸 is-small is-medium is-large >folded1234567891011121314151617&lt;article class=&quot;message is-small&quot;&gt; &lt;div class=&quot;message-body&quot;&gt; is-small &lt;/div&gt;&lt;/article&gt;&lt;article class=&quot;message is-medium&quot;&gt; &lt;div class=&quot;message-body&quot;&gt; is-medium &lt;/div&gt;&lt;/article&gt;&lt;article class=&quot;message is-large&quot;&gt; &lt;div class=&quot;message-body&quot;&gt; is-large &lt;/div&gt;&lt;/article&gt; 颜色 is-light is-dark is-primary is-info is-success is-warning is-danger >folded1234567891011121314151617181920212223242526272829303132333435363738394041&lt;article class=&quot;message is-light&quot;&gt; &lt;div class=&quot;message-body&quot;&gt; is-light &lt;/div&gt;&lt;/article&gt;&lt;article class=&quot;message is-dark&quot;&gt; &lt;div class=&quot;message-body&quot;&gt; is-dark &lt;/div&gt;&lt;/article&gt;&lt;article class=&quot;message is-primary&quot;&gt; &lt;div class=&quot;message-body&quot;&gt; is-primary &lt;/div&gt;&lt;/article&gt;&lt;article class=&quot;message is-info&quot;&gt; &lt;div class=&quot;message-body&quot;&gt; is-info &lt;/div&gt;&lt;/article&gt;&lt;article class=&quot;message is-success&quot;&gt; &lt;div class=&quot;message-body&quot;&gt; is-success &lt;/div&gt;&lt;/article&gt;&lt;article class=&quot;message is-warning&quot;&gt; &lt;div class=&quot;message-body&quot;&gt; is-warning &lt;/div&gt;&lt;/article&gt;&lt;article class=&quot;message is-danger&quot;&gt; &lt;div class=&quot;message-body&quot;&gt; is-danger &lt;/div&gt;&lt;/article&gt; 沉浸式 message-immersive >folded12345&lt;article class=&quot;message message-immersive&quot;&gt; &lt;div class=&quot;message-body&quot;&gt; message-immersive &lt;/div&gt;&lt;/article&gt; 带图标 primary danger >folded1234567891011&lt;article class=&quot;message message-immersive is-primary&quot;&gt; &lt;div class=&quot;message-body&quot;&gt; &lt;i class=&quot;fas fa-info-circle mr-2&quot;&gt;&lt;/i&gt;primary &lt;/div&gt;&lt;/article&gt;&lt;article class=&quot;message message-immersive is-danger&quot;&gt; &lt;div class=&quot;message-body&quot;&gt; &lt;i class=&quot;fas fa-exclamation-triangle mr-2&quot;&gt;&lt;/i&gt;danger &lt;/div&gt;&lt;/article&gt; 图标 图标 写法 &lt;i class=&quot;fas fa-info-circle&quot;&gt;&lt;/i&gt; &lt;i class=&quot;fas fa-minus-circle&quot;&gt;&lt;/i&gt; &lt;i class=&quot;fas fa-times-circle&quot;&gt;&lt;/i&gt; &lt;i class=&quot;fas fa-user-circle&quot;&gt;&lt;/i&gt; &lt;i class=&quot;fas fa-arrow-circle-down&quot;&gt;&lt;/i&gt; &lt;i class=&quot;fas fa-arrow-circle-up&quot;&gt;&lt;/i&gt; &lt;i class=&quot;fas fa-check-circle&quot;&gt;&lt;/i&gt; &lt;i class=&quot;fas fa-question-circle&quot;&gt;&lt;/i&gt; 更多图标参考：https://fontawesome.com/v5/search 公共类default.css >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117.ml-0 { margin-left: 0 !important; }.mr-0 { margin-right: 0 !important; }.ml-n0 { margin-left: 0 !important; }.mr-n0 { margin-right: 0 !important; }.mt-0 { margin-top: 0 !important; }.mb-0 { margin-bottom: 0 !important; }.mt-n0 { margin-top: 0 !important; }.mb-n0 { margin-bottom: 0 !important; }.pl-0 { padding-left: 0 !important; }.pr-0 { padding-right: 0 !important; }.pl-n0 { padding-left: 0 !important; }.pr-n0 { padding-right: 0 !important; }.pt-0 { padding-top: 0 !important; }.pb-0 { padding-bottom: 0 !important; }.pt-n0 { padding-top: 0 !important; }.pb-n0 { padding-bottom: 0 !important; }.mr-1 { margin-right: 0.25rem !important; }.ml-n1 { margin-left: -0.25rem !important; }.mr-n1 { margin-right: -0.25rem !important; }.mt-1 { margin-top: 0.25rem !important; }.mt-n1 { margin-top: -0.25rem !important; }.mb-n1 { margin-bottom: -0.25rem !important; }.pl-1 { padding-left: 0.25rem !important; }.pr-1 { padding-right: 0.25rem !important; }.pl-n1 { padding-left: -0.25rem !important; }.pr-n1 { padding-right: -0.25rem !important; }.pt-1 { padding-top: 0.25rem !important; }.pb-1 { padding-bottom: 0.25rem !important; }.pt-n1 { padding-top: -0.25rem !important; }.pb-n1 { padding-bottom: -0.25rem !important; }.ml-2 { margin-left: 0.5rem !important; }.mr-2 { margin-right: 0.5rem !important; }.ml-n2 { margin-left: -0.5rem !important; }.mr-n2 { margin-right: -0.5rem !important; }.mt-2 { margin-top: 0.5rem !important; }.mb-2 { margin-bottom: 0.5rem !important; }.mt-n2 { margin-top: -0.5rem !important; }.mb-n2 { margin-bottom: -0.5rem !important; }.pl-2 { padding-left: 0.5rem !important; }.pr-2 { padding-right: 0.5rem !important; }.pl-n2 { padding-left: -0.5rem !important; }.pr-n2 { padding-right: -0.5rem !important; }.pt-2 { padding-top: 0.5rem !important; }.pb-2 { padding-bottom: 0.5rem !important; }.pt-n2 { padding-top: -0.5rem !important; }.pb-n2 { padding-bottom: -0.5rem !important; }.ml-3 { margin-left: 1rem !important; }.mr-3 { margin-right: 1rem !important; }.ml-n3 { margin-left: -1rem !important; }.mr-n3 { margin-right: -1rem !important; }.mt-3 { margin-top: 1rem !important; }.mt-n3 { margin-top: -1rem !important; }.mb-n3 { margin-bottom: -1rem !important; }.pl-3 { padding-left: 1rem !important; }.pr-3 { padding-right: 1rem !important; }.pl-n3 { padding-left: -1rem !important; }.pr-n3 { padding-right: -1rem !important; }.pt-3 { padding-top: 1rem !important; }.pb-3 { padding-bottom: 1rem !important; }.pt-n3 { padding-top: -1rem !important; }.pb-n3 { padding-bottom: -1rem !important; }.ml-4 { margin-left: 1.5rem !important; }.ml-n4 { margin-left: -1.5rem !important; }.mr-n4 { margin-right: -1.5rem !important; }.mt-4 { margin-top: 1.5rem !important; }.mb-4 { margin-bottom: 1.5rem !important; }.mt-n4 { margin-top: -1.5rem !important; }.mb-n4 { margin-bottom: -1.5rem !important; }.pl-4 { padding-left: 1.5rem !important; }.pr-4 { padding-right: 1.5rem !important; }.pl-n4 { padding-left: -1.5rem !important; }.pr-n4 { padding-right: -1.5rem !important; }.pt-4 { padding-top: 1.5rem !important; }.pb-4 { padding-bottom: 1.5rem !important; }.pt-n4 { padding-top: -1.5rem !important; }.pb-n4 { padding-bottom: -1.5rem !important; }.ml-5 { margin-left: 3rem !important; }.mr-5 { margin-right: 3rem !important; }.ml-n5 { margin-left: -3rem !important; }.mr-n5 { margin-right: -3rem !important; }.mt-5 { margin-top: 3rem !important; }.mb-5 { margin-bottom: 3rem !important; }.mt-n5 { margin-top: -3rem !important; }.mb-n5 { margin-bottom: -3rem !important; }.pl-5 { padding-left: 3rem !important; }.pr-5 { padding-right: 3rem !important; }.pl-n5 { padding-left: -3rem !important; }.pr-n5 { padding-right: -3rem !important; }.pt-5 { padding-top: 3rem !important; }.pb-5 { padding-bottom: 3rem !important; }.pt-n5 { padding-top: -3rem !important; }.pb-n5 { padding-bottom: -3rem !important; }.ml-auto { margin-left: auto !important; }.mr-auto { margin-right: auto !important; }.mt-auto { margin-top: auto !important; }.mb-auto { margin-bottom: auto !important; }.pl-auto { margin-left: auto !important; }.pr-auto { margin-right: auto !important; }.pt-auto { margin-top: auto !important; }.pb-auto { margin-bottom: auto !important; }.order-0 { order: 0 !important; }.order-1 { order: 1 !important; }.order-2 { order: 2 !important; }.order-3 { order: 3 !important; }.order-4 { order: 4 !important; }.order-5 { order: 5 !important; }.justify-content-start { justify-content: start !important; }.justify-content-center { justify-content: center !important; }.flex-shrink-1 { flex-shrink: 1 !important; }","link":"/2018/12/31/Icarus%E5%86%99%E4%BD%9C%E6%96%87%E6%A1%A3/"},{"title":"JavaScript基础","text":"闭包（closure） 所谓闭包指的是有权访问另一个函数作用域中变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数。本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 12345678function fn1() { var n = 999 return function() { alert(n) }}var result = fn1()result() 上面的例子fn1函数中返回了一个匿名函数，这个匿名函数访问了fn1中的变量n。即使这个匿名函数被返回，然后在其他地方调用了，但它仍然可以访问到n。因此，我们可以在函数体外访问到函数体内的变量。这就是闭包的两大用处之一——读取函数内部的变量，另一个是让这些变量始终保存在内存中。看一下这个例子就明白了： 123456789101112131415function fn1() { var n = 999 // 注意nAdd是全局变量 nAdd = function() { n += 1 } function fn2() { console.log(n) } return fn2}var result = fn1()result() // 999nAdd()result() // 1000 上例中fn2被赋值给了一个全局变量，因此它始终在内存中，而fn2的存在依赖于fn1，因此fn1也始终在内存中。 下面的例子会返回一个函数数组，我们期望函数返回当前位置的索引： 12345678910function createFunctions() { var result = [] for(var i = 0; i &lt; 10; i++) { result[i] = function() { return i } } return result}createFunctions()[0]() // 10 实际上，无论是第几项返回的都是10。因为每个函数的作用域链中都保存着createFunctions()函数的活动对象，所有他们引用的都是同一个变量i。要使函数符合预期，可以这样： {4,5,6,7,8}12345678910function createFunctions() { var result = [] for(var i = 0; i &lt; 10; i++) { result[i] = function(num) { return function() { return num } }(num) }} 这一次，我们没有直接将闭包赋值给数组。而是定义了一个匿名函数，并将立即执行函数的结果赋值给了数组。由于函数参数是按值传递的，所以就会将变量i的当前值复制给参数num。这样一来，result数组中的每个函数都有自己num变量的一个副本，因此就可以返回各自不同的值了。 严格来说，内存泄漏并不是闭包的缺点，这是IE9之前的版本对JScript和COM对象使用不同的垃圾回收例程所导致的。由于闭包的特性，函数体内的变量会被保存在内存中不被释放，因此频繁的使用闭包还是会造成大量的内存消耗，影响网页性能。解决办法是在退出函数前，将不使用的局部变量删除。 原型和原型链构造函数JavaScript通过构造函数来生成新对象，因此构造函数可以视为对象的模板。 1234567function Cat(name, color) { this.name = name this.color = color}let cat1 = new Cat('大毛', '白色')cat1.name // '大毛'cat1.color // '白色' new 操作符在这里都干了什么？ 创建一个新对象； 将构造函数的作用域赋给新对象（因此this就指向了这个新对象）； 执行构造函数中的代码（为这个新对象添加属性）； 返回新对象（如果构造函数中显式返回了一个对象类型，则是返回的那个对象）。 通过上面的描述可以用代码表示new操作符的简易流程。 12345678910111213141516/** * constructor 构造函数 * params 构造函数参数 */function _new(constructor, params) { // 将arguments转化为数组 const args = [].slice.call(arguments) // 取出构造函数 const constructor = args.shift() // 创建一个新对象，继承构造函数的prototype属性 const context = Object.create(constructor.prototype) // 执行构造函数 const rusult = constructor.apply(context, args) // 如果返回结果是对象，就直接返回，否则返回context return (typeof rusult === 'object' &amp;&amp; result != null) ? result : context} 通过构造函数来为实例对象定义属性很方便，但是有一个缺点，就是构造函数的多个实例无法共享属性，造成对资源的浪费。 12345678910function Cat(name, color) { this.name = name this.color = color this.eat = function () { console.log(`${this.name} eatting.`) }}const cat1 = new Cat('Tom', 'blue')const cat2 = new Cat('Lucy', 'pink')cat1.eat === cat2.eat // false 上面的代码中，cat1和cat2分别是Cat的两个实例，他们都有eat方法。由于eat方法是生成在每个对象实例上面，所以两个对象就生成了两次。也就是说，每新建一个实例，就会新建一个eat方法。这没有必要又浪费系统资源，因为eat方法都是相同的行为，完全可以共享。这个问题的解决办法，就是JavaScript的原型对象（prototype）。 prototypeJavaScript规定，每个函数都有一个prototype属性，指向一个对象。 12function fn() {}typeof fn.prototype // 'object' 对于普通函数而言，这个属性基本是无用的。但是对于构造函数来说，该属性会自动成为实例对象的原型。 原型对象的属性不是实例对象自身的属性。只要改变了原型对象，变动就立即会体现在所有的实例对象上。 之所以被成为原型对象，是因为实例对象可以视作从原型对象衍生出来的子对象。 原型链JavaScript规定，所有对象都有自己的原型对象（prototype）。一方面，任何一个对象都可以充当其他对象的原型，而原型对象也是对象，它也有自己的原型，因此就形成了原型链。如此追溯，可以一直追溯到Object.prototype。常见的valueOf、toString就是定义在该原型上，而Object.prototype它的原型就是null了。 1Object.getPrototypeOf(Object.prototype) // null Object.getPrototypeOf( object )返回指定对象的原型（内部[[Prototype]]属性的值）。 读取对象属性，JS引擎先在对象本身中查找，如果找不到，就到它的原型中找，如果还找不到，就到原型的原型中找。如果直到顶层的Object.prototype还是找不到，就返回undefined。如果对象本身和原型都有这个属性，那么就优先读取对象本身的属性，原型的属性会被覆盖。 也就是说，如果构造函数的prototype指向一个数组，那么实例对象就可以使用数组的方法了。 1234567const arr = function() {}arr.prototype = new Array()arr.prototype.constructor = arrconst instanceArr = new arr()instanceArr.push(1, 2, 3)instanceArr.length() // 3instanceArr instanceof Array // true constructorprototype对象上有一个constructor属性，默认指向prototype对象所在的构造函数。 12function fn() {}fn.prototype.constructor === fn // true 要注意的是，在修改prototype对象时，一般要同时修改constructor属性的指向。 12345678910111213// 坏的写法C.prototype = { method1: function (...) { ... }, // ...};// 好的写法C.prototype = { constructor: C, method1: function (...) { ... }, // ...};// 更好的写法C.prototype.method1 = function (...) { ... }; 结合一张图来理解原型链可能更好： 构造函数的继承让一个构造函数继承另一个构造函数是非常常见的需求。这可以分两步实现，第一步是在子类的构造函数中调用父类的构造函数。 1234function Sub(value) { Super.call(this) this.prop = value} call() 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数。call和apply类似，唯一的区别是call接收一个参数列表，而apply接收的是一个包含多个参数的数组。 第二步，让子类的原型指向父类的原型，这样子类就可以继承父类原型。 123Sub.prototype = Object.create(Super.prototype)Sub.prototype.constructor = Sub// ... Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。 Object.create()和{}的区别： Object.create(Object.prototype)相当于{} Sub.prototype是子类的原型，要将它赋值为Object.create(Super.prototype)，而不是直接等于Super.prototype。否则后面两行对Sub.prototype的操作，会连父类的原型Super.prototype也一起修改掉。 另一种写法是Sub.prototype等于一个父类的实例。 1Sub.prototype = new Super() 上面这个方法也可以实现继承，但是子类也会继承父类实例的方法，有时候这可能不是我们需要的，因此不推荐这种写法。 混入由上面这种继承的方式也可以衍生出混入继承，即一个子类同时继承两个或多个父类的属性和方法。 12345678910111213function Super(name) { this.name = name}function OtherSuper(age) { this.age = age}function Sub(name, age) { Super.call(this, name) OtherSuper.call(this, age)}Sub.prototype = Object.create(Super.prototype)Object.assign(Sub.prototype, OtherSuper.prototype)Sub.prototype.constructor = Sub 当然还有ES6的继承方式，这里不累述了。 this 关于this是一个老生常谈的话题了，记住一点：this永远指向最后调用它的那个对象。先来一个简单的例子： 123456var name = 'windowName'function fn() { var name = 'linhe' console.log(this.name)}fn() // windowName 用this永远指向最后调用它的那个对象来解释一下，前面没有调用对象那么就是全局对象window，因此在全局找name然后就找到了windowName。 再换一个例子看看： 12345678var name = 'windowName'var obj = { name: 'linhe', fn: function() { console.log(this.name) }}console.log(obj.fn()) // linhe 还是用这句话就很好理解了，调用fn的对象是obj，所以this.name就是linhe。 改动一下看看： 12345678var name = 'windowName'var obj = { fn: function() { console.log(this.name) }}var fn = obj.fnfn() // windowName 看到这里可能会有点疑惑，fn不是指向obj.fn吗？再仔细看看this永远指向最后调用它的那个对象，在将obj.fn重新赋值的时候其实并没有调用对象的这个方法，真正调用是在最后一行代码，还是全局调用，所以是windowName。 到这里，不管什么样的句式应该都不成问题了。 12345678var name = 'windowName'function fn() { var name = 'linhe' innerFunc() function innerFunc() { console.log(this.name) // windowName }} 看看吧，就算在函数体内调用，没有对象调用函数那就是全局调用。 改变this指向的方法： 使用ES6箭头函数； 在函数内部保存this(_this = this); 使用call、apply、bind； new实例化一个对象。 12345678910111213var name = 'windowName'var obj = { name: 'linhe', func1: function() { console.log(this.name) }, func2: function() { setTimeout(function() { this.func1() }, 1000) }}obj.func2() // this.func1 is not a function setTimeout是全局方法，它内部的回调函数指向全局，而全局没有func1方法，因此就报错了。 按照上面说的几点，改变this的指向试试： 箭头函数：箭头函数的this始终指向函数定义时的this，而非执行时。箭头函数内部没有 this，它始终沿用上一个作用域栈中的this。 12345678910111213var name = 'windowName'var obj = { name: 'linhe', func1: function() { console.log(this.name) }, func2: function() { setTimeout(() =&gt; { this.func1() }, 1000) }}obj.func2() // linhe 在函数内部使用变量存储this的指向 1234567891011121314var name = 'windowName'var obj = { name: 'linhe', func1: function() { console.log(this.name) }, func2: function() { var _this = this setTimeout(function() { _this.func1() }, 1000) }}obj.func2() // linhe 使用call、apply、bind 123456789101112131415161718192021222324252627282930313233343536373839404142// callvar name = 'windowName'var obj = { name: 'linhe', func1: function() { console.log(this.name) }, func2: function() { setTimeout(function() { this.func1() }.call(obj), 1000) }}obj.func2() // linhe// applyvar name = 'windowName'var obj = { name: 'linhe', func1: function() { console.log(this.name) }, func2: function() { setTimeout(function() { this.func1() }.apply(obj), 1000) }}obj.func2() // linhe// bindvar name = 'windowName'var obj = { name: 'linhe', func1: function() { console.log(this.name) }, func2: function() { setTimeout(function() { this.func1() }.bind(obj), 1000) }}obj.func2() // linhe 说一下上述三个方法的第一个参数，它是一个对象。call、apply、bind都是函数的方法，调用方法改变函数体内this的指向，改为指向第一个参数（对象）,在非严格模式下，第一个参数为null或undefined时，函数体内的this则指向全局对象。 这里有一点需要注意：上面的call、apply返回的是函数的调用，也就是执行this.func1()，而this.func1()的返回值是undefined，这样的代码在真正的业务中并不适用，因为这会导致setTimeout立即执行。而bind返回的是setTimeout回调函数的拷贝，在业务中逻辑合理，会延迟一秒执行func1，打印出linhe。 手写call、apply、bind:top: 上面说到关于this指向问题时已经谈到过这三个方法可以改变函数的this指向，那么先来看看call、apply、bind各自的定义和区别先： callcall()方法使用指定的this值和单独给出的一个或多个参数来调用一个函数。 语法： function.call(thisArg, arg1, arg2, …)参数thisArg是可选的，它指的是function函数运行时使用的this值。在非严格模式下，当thisArg为null或undefined时，this指向全局对象，在浏览器中就是window。 参数arg1, arg2, ...是要传入function的参数列表。 applyapply和call方法类似，只有一个区别，就是call()方法接受的是一个参数列表，而apply()方法接受的是一个包含多个参数的数组。 语法： function.apply(thisArg, [arg1, arg2, …]) bindbind()方法创建一个新函数，在bind()被调用时，这个新函数的this被指定为bind()的第一个参数，而其余参数将作为新函数的参数，供调用时使用。bind()返回原函数的拷贝，并拥有指定的this值和初始参数。 语法： function.bind(thisArg[, arg1 [, arg2[, …]]])了解了概念之后，我们再来看看手写call、apply、bind的实现方式。 手写call先来一个原生call的使用方式： 123456789101112let Person = { name: 'linhe', say: function() { console.log(this.name) }}Person.say() // linhelet p1 = { name: 'Tom'}// 原生callPerson.say.call(p1) // Tom 通过上面的示例我们发现：如果p1有say()方法，执行p1.say()可以得到和Person.say.call(p1)同样的结果。没错这就是call的实现原理。 12345678Function.prototype.myCall = function(context) { // context就是上例的p1对象 // this结合上例就是Person.say()方法 context.say = this // 立即执行 context.say()}Person.say.myCall(p1) // Tom 就是这么简单，不过还有几点需要完善： 支持多个参数； 给上下文定义的函数要保持唯一； 调用完函数后要进行删除。 12345678910111213141516171819202122232425262728Function.prototype.myCall = function() { // 没有参数或者为null指向window let context = arguments[0] == null ? window : arguments[0] // 创建一个唯一的方法名，防止被调用的对象本来有同名方法而被覆盖 let fn = Symbol('fn') // 把要借用的方法拷贝到对象方法上 context[fn] = this // 截取参数 let arg = [...arguments].slice(1) // 立即调用 const result = context[fn](...arg) // 删除 delete context[fn] // 返回结果 return result}// 测试let person = { name: 'linhe', say(age) { console.log(`我的名字：${this.name}，我的年龄：${age}岁`) }}let p1 = { name: 'Tom'}person.say.myCall(p1, 18)person.say.myCall(null, 18) 手写apply12345678910Function.prototype.myApply = function() { let context = arguments[0] == null ? window : arguments[0] let fn = Symbol('fn') context[fn] = this // apply第二个参数是数组 let args = arguments[1] || [] const result = context[fn](...args) delete context[fn] return result} 手写bind123456789101112Function.prototype.myBind = function() { let context = arguments[0] == null ? window : arguments[0] //返回一个绑定this的函数，我们需要在此保存this let self = this // 可以支持柯里化传参（fn.bind(a)(b)），保存参数 let args = [...arguments].slice(1) // 返回函数 return function() { let newArgs = return self.apply(context, [...args, ...arguments]) }} 宏任务和微任务","link":"/2020/07/12/JavaScript%E5%9F%BA%E7%A1%80/"},{"title":"encodeURI和decodeURI","text":"首先说一下URI和URL的区别，其中的I指的是Indentifier，L指的是Locater。前者是统一资源标识符，后者则是统一资源定位符。解释得通俗一点URI相当于一个人的身份证号，我可以标识出一个唯一的人，而URL则相当于这个人的详细地址，同样可以标识出一个唯一的人，但是URL是URI的一种实现，它是URI的子集。URL就是用定位的方式实现的URI。进入正题，首先来看一下encodeURI的定义：encodeURI() 函数通过将特定字符的每个实例替换为一个、两个、三或四转义序列来对统一资源标识符 (URI) 进行编码 (该字符的 UTF-8 编码仅为四转义序列)由两个 “代理” 字符组成)。（MDN） 为什么要编码呢？这是因为url只能使用英文字母、阿拉伯数字和某些标点符号，不能使用其他文字和符号。而RFC 1738没有规定具体的编码方法，而是交给应用程序（浏览器）自己决定。这就造成了各种浏览器的处理方式不大一样，如果开发者需要去兼容各种不同的浏览器的话，那太麻烦了。像IE8就算是特殊字符在网址路径（host）和在查询字符串中的处理方式也不一样（但大部分都根据utf-8或者GB2312编码）。因此我们必须使用JS先对URL编码，然后再向服务器提交，不让浏览器插手编码工作。这就促使了JS有encodeURI()和encodeURIComponent()函数及对应的解码函数。 但这两个函数还稍有不同。 encodeURIencodeURI()着眼于对整个URL进行编码，因此除了常见的符号以外，对其他一些在网站中有特殊含义的符号 ; / ? : @ &amp; = + $ , # 等不进行编码。它输出符号的utf-8形式，并且在每个字节前加上%。它的对应解码函数是decodeURI()。 encodeURIComponentencodeURIComponent()用于对URL的组成部分进行个别编码，因此在上文中提到不被encodeURI()编码的特殊符号在encodeURIComponent()中通通会被编码。编码方式也是utf-8,并且在每个字节前加上%。它的对应解码函数是decodeURIComponent()。 由上面两张图可以看出对比，encodeURI不对@编码，而encodeURIComponet()则会编码。像中文之类的符号则都会编码，并且格式一样。","link":"/2022/07/12/encodeURI%E5%92%8CdecodeURI/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2018/12/31/hello-world/"},{"title":"函数柯里化","text":"什么是柯里化（curry） 在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。而对于JavaScript语言来说，我们通常说的柯里化函数的概念，与数学和计算机科学中的柯里化的概念并不完全一样。在数学和计算机科学中的柯里化函数，一次只能传递一个参数；而我们JavaScript实际应用中的柯里化函数，可以传递一个或多个参数。 柯里化的用途看起来柯里化似乎把简单的问题复杂化了，但在复杂化的同时，我们在使用函数时就拥有了更加多的自由度。柯里化本质上是降低通用性，提高适用性。 来看看在实际业务中的使用场景： 正则验证 12345function checkByRegExp(regExp,string) { return regExp.test(string)}checkByRegExp(/^1\\d{10}$/, '18642838455')checkByRegExp(/^(\\w)+(\\.\\w+)*@(\\w)+((\\.\\w+)+)$/, 'test@163.com') // 校验邮箱 这样的封装咋一看好像没什么问题（其实本来就没问题），但是当我们需要验证多个手机号码时，那就是这么写的： 123checkByRegExp(/^1\\d{10}$/, '18642838455')checkByRegExp(/^1\\d{10}$/, '13109840560')checkByRegExp(/^1\\d{10}$/, '13204061212') 众所周知，攻城狮们都是代码的搬运工，那肯定要考虑怎么样才更省力才行，像上面这样使用多个相同的正则是无法容忍的，最好能这么样： 1234567//进行柯里化let _check = curry(checkByRegExp)//生成工具函数，验证电话号码let checkCellPhone = _check(/^1\\d{10}$/)checkCellPhone('18642838455')checkCellPhone('13109840560')checkCellPhone('13204061212') 是不是看起来优雅了很多，从这个例子可以更好的理解所谓柯里化会使函数降低通用性的同时提高适用性这句话了。而这种通过函数柯里化提取参数的方式可以理解为参数复用。 那么，具体的curry函数实现应该是怎样呢？ 一个简单的例子： 1234function add(a, b, c) { return a + b + c}add(1, 2) 这是一个普通的函数调用，我们希望可以add(1)(2)(3)像这样调用函数。 实现： 123456789101112function curry(fn, args) { const length = fn.length // 获取要柯里化的函数的形参总长度 const currentArgs = args || [] // 获取当前函数在调用前的实参 return function() { const _args = [...currentArgs, ...arguments] // 当前实参的集合 if (_args.length &lt; length) { return curry.call(this, fn, _args) // 递归逻辑 - 实参的长度小于形参时返回一个函数用来接收剩余参数 } else { return fn.apply(this, _args) // 终止条件 } }}","link":"/2022/07/12/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/"},{"title":"前端实现图片压缩上传","text":"前端实现图片压缩上传我觉得还是很有必要的, 现在移动web页面越来越多, 活动页很多都牵涉到图片上传难问题, 而用户手机像素又很高, 随随便便一张图片就是5~10M, 要是一次要上传多张图片的话, 第一个时间花费太多, 第二个就是用户的流量也要耗费不少, 而如果实现前端图片压缩则能很好的避开这两个问题. 我的基本思路是用户通过input[file]输入框添加了文件后, 读取图片信息, 将图片画到Canvas画布上, 然后再转成图片来实现压缩上传。 核心API1canvas.getContext('2d').drawImage(img, dx, dy, dWidth, dHeight) img 图片对象 dx 将图片画到canvas上时图片左上角在画布上的x坐标 dy 将图片画到canvas上时图片左上角在画布上的y坐标 dWidth 将图片画到canvas上时图片要画的宽度 dHeight 将图片画到canvas上时图片要画的高度 实现流程 用户点击input[file]选择图片后的逻辑1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;input type=&quot;file&quot; accept=&quot;image/*&quot; onchange=&quot;uploadImageHandle&quot;/&gt;&lt;script&gt; function uploadImageHandle(e) { // 创建实例 var reader = new FileReader(), img = new Image(); // 读取上传的图片的信息(lastModified, lastModifiedDate, name, size, type等) var file = e.target.files[0]; // 记下上传的图片的类型, 后面会用到 var fileType = file.type; // 生成canvas画布 var canvas = document.createElement('canvas'); var context = canvas.getContext('2d'); // MDN: 该方法会读取指定的 Blob 或 File 对象。读取操作完成的时候， // readyState 会变成已完成（DONE），并触发 loadend 事件， // 同时 result 属性将包含一个data:URL格式的字符串（base64编码）以表示所读取文件的内容。 // 也就是说, 将File对象转化为base64位字符串 reader.readAsDataURL(file); // 上一步是异步操作, 读取完成后会执行onload事件, 而base64的字符串在e.target.rusult中 reader.onload = function(e) { // 获得图片dom img.src = e.target.result; console.log( img ) } img.onload = function() { // 图片原始尺寸 var originWidth = this.width; var originHeight = this.height; // 最大尺寸限制 var maxWidth = 800, maxHeight = 800; // 目标尺寸 var targetWidth = originWidth, targetHeight = originHeight; // 图片尺寸超过800x800的限制 if (originWidth &gt; maxWidth || originHeight &gt; maxHeight) { if (originWidth / originHeight &gt; maxWidth / maxHeight) { // 更宽，按照宽度限定尺寸 targetWidth = maxWidth; targetHeight = Math.round(maxWidth * (originHeight / originWidth)); } else { targetHeight = maxHeight; targetWidth = Math.round(maxHeight * (originWidth / originHeight)); } } // canvas对图片进行缩放 canvas.width = targetWidth; canvas.height = targetHeight; // 清除画布 context.clearRect(0, 0, targetWidth, targetHeight); // 将图片划到canvas上 context.drawImage(img, 0, 0, 800, 800); // 把canvas转成base64格式并去除头 var base64 = canvas.toDataURL(fileType).replace(/^data:image\\/(jpeg|jpg|png|gif);base64,/,''); // 上传base64, 如果需要上传图片只需要参照上面的操作, 重复将base64设置为图片上的src就行了. 当然, 需要在去处头之前 axios.post('https://yourdomain.com/api/xxx', { imageSrc: base64 }).then(res =&gt; { console.log( res ) }).catch(err =&gt; { console.log( err ) }) }&lt;/script&gt; 如此, 就实现了图片的压缩上传功能, 其实还是很简单的, 这么没有做实时预览功能, 不过已经写到这一步了(FileReader), 实现预览功能也非常容易, 这就是今天内容的全部了, 图片上传使用得越来越频繁, 做个记录, 省得每次做的时候都要去翻资料。","link":"/2019/06/15/%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E4%B8%8A%E4%BC%A0/"},{"title":"常用Git命令","text":"名词解释: Workspace(工作区) Index/Stage(暂存区) Repository(仓库区) Remote(远程仓库) 1. 增加/删除文件12345678910111213141516171819# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 修改文件名# 此命令可用于需要修改文件大小写时有效，# git默认忽略识别大小写，通过执行以下命令可使文件变为 renamed 状态，此时提交可修改文件名$ git mv [oldfilename] [newfilename]# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file] 2. 代码提交123456789101112131415# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 3. 列出分支、新建分支、删除分支123456789101112131415161718192021222324252627282930313233343536# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git switch -c [branch]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git switch [branch-name]# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]$ git branch -u origin/master # 简写# 合并指定分支到当前分支$ git merge [branch]# 删除分支，使用 -D 强制删除$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]# 修改本地分支名称$ git branch -m [old-branch-name] [new-branch-name] 4. 撤销HEAD 表示当前活跃分支的游标。你当前在哪儿，HEAD就指向哪儿。HEAD^的意思是上一个版本，也可以写成HEAD~1，如果要指向前两个版本就是HEAD~2。 git reset 和 git revert 的区别：首先它们都能使工作区回到上一次提交之前的某种状态，但 git reset 是直接在历史记录中删除上一次的 commitID，而git revert 则是在历史记录中追加一个新的 commitID 来回到过去的状态。 reset 的 3 个参数： 1. –mixed 不删除工作空间改动代码，撤销 commit，撤销git add . 操作。这个为默认参数,git reset --mixed HEAD^ 和 git reset HEAD^ 效果是一样的。 2. –soft 不删除工作空间改动代码，撤销 commit，不撤销git add . 操作。也就是将已经提交到仓库区的提交记录撤回到暂存区。 3. –hard 删除工作空间改动代码，撤销 commit，撤销git add .操作。注意完成这个操作后，就恢复到了上一次的commit状态。 1234567891011121314151617181920212223242526272829303132333435363738# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与指定commit保持一致$ git reset --hard [commitID]# 撤销上一次commit到暂存区，工作区保持不变$ git reset --soft HEAD^# 查看最近的提交记录（可查看commitId）$ git reflog# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash save [message]$ git stash list$ git stash pop [index]# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout . 5. 远程同步1234567891011121314151617181920212223# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库和仓库地址$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 修改云成功仓库的地址$ git remote set-url origin [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 推送所有分支到远程仓库$ git push [remote] --all 6. 查看信息123456789101112131415161718192021222324252627282930313233343536373839404142# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示精简的版本信息$ git log --oneline# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示某次提交的元数据和内容变化$ git show [commit] 7. 标签1234567891011121314151617181920212223242526# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag]","link":"/2019/08/22/%E5%B8%B8%E7%94%A8Git%E5%91%BD%E4%BB%A4/"},{"title":"常用字符串方法","text":"charAt(x) charAt(x) 返回字符串中 x 位置的字符，下标从 0 开始。 12const str = 'hello world!'str.charAt(4) // 'o' concat(v1, v2, …) concat() 方法用于连接两个或多个字符串，此方法不改变现有的字符串，返回拼接后的新字符串。 12345const str1 = 'hello'const str2 = ' 'const str3 = 'world'const concatStr = str1.concat(str2, str3)console.log(concatStr) // hello world indexOf(substr, [start]) indexOf() 方法搜索并（如果找到）返回字符串中搜索到的字符或子字符串的索引。如果没有找到，则返回 -1。start 是一个可选参数，指定字符串中开始搜索的位置（包含该位置），默认值为 0。 我们一般使用这个方法循环查找字符串中所有的相同字符。 12const str = 'hello world!'str.indexOf('l', 3) // 3 lastIndexOf(substr, [start]) lastIndexOf() 方法返回指定文本在字符串中最后一次出现的索引，如果没有找到，则返回 -1. start 是一个可选参数，指定字符串中开始搜索的位置，默认值为 string.length - 1。 虽然是从后面开始查找，但在指定 start 参数时还是从第一个字符计算索引，像下面的例子指定的就是从 world 中的 l 开始向前查找 l 字符，包含本身。 12const str = 'hello world!'str.lastIndexOf('l', 9) // 9 match(regexp) 根据正则表达式在字符串中搜索匹配项。如果没有找到匹配项，则返回一个信息数组或 null。 123456789101112//match(regexp) //select integers onlyvar intRegex = /[0-9 -()+]+$/;var myNumber = '999';var myInt = myNumber.match(intRegex);console.log(isInt);//output: 999var myString = '999 JS Coders';var myInt = myString.match(intRegex);console.log(isInt);//output: null replace(regexp/substr, replacetext) replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。 123const str = 'hello world'str.replace('l', 'L') // heLlo worldstr.replace(/l/g, 'L') // heLLo worLd slice(start, [end]) slice() 方法可提取字符串的某个部分，返回一个新的字符串。包括字符串从 start 开始（包括 start）到 end 结束（不包括 end）为止的所有字符。 12const str = 'hello world'str.slice(0, 4) // hell split(delimiter, [limit]) split() 方法用于把一个字符串分割成字符串数组，返回一个字符串数组，返回的数组中的子串不包括 delimiter 自身。可选的 limit 是一个整数，允许指定要返回的最大数组的元素个数。 12const str = 'hello world'str.split(' ', 1) // ['hello'] substr(start, [length])substr() 方法可在字符串中抽取从 start 下标开始的指定数目的字符。返回一个新的字符串，包含从 start （包括 start 所指的字符）处开始的 length 个字符。如果没有指定 length，那么返回的字符串包含从 start 到该字符串的结尾的字符。 12const str = 'hello world'str.substr(2, 5) // &quot;llo w&quot; substring(from, [to]) substring() 方法用于提取字符串介于两个指定下标之间的字符，返回的子串包括 start 处的字符，但不包括 to 处的字符，to 可选，如果省略这个参数，那么返回的子串会一直到字符串的结尾。 12const str = 'hello world'str.substring(2, 5) // &quot;llo&quot; toLowerCase() toLowerCase() 方法用于把字符串转换为小写。 12const str = 'Hello World'str.toLowerCase() // &quot;hello world&quot; toUpperCase() toUpperCase() 方法用于把字符串转换为大写。 12const str = 'hello world'str.toUpperCase() // &quot;HELLO WORLD&quot; includes() includes() 方法用于检查字符串是否包含指定的字符串或字符，返回一个布尔值。 12const str = 'hello world'str.includes(' ') // true valueOf() valueOf() 方法返回一个 String 对象的原始值（primitive value），该值等同于 String.prototype.toString()。 12const str = 'hello world'str.valueOf() // 'hello world' trim() trim() 方法会从一个字符串的两端删除空白字符。在这个上下文中的空白字符是所有的空白字符（space、tab、no-break space 等）以及所有行终止符（如 LF、CR）。需要删除所有的空格可使用 str.replace(/\\s/g, '')。 12const str = ' hello wrold 'str.trim() // 'hello world'","link":"/2022/07/12/%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95/"},{"title":"我的装机软件","text":"常用软件 GoogleHelper EveryThing PotPlayer Bindizip Honeyview Scrcpy MacType 开发相关软件 PowerShell nvm-windows XShell &amp; XFTP 开发辅助库 markdown-it-emoji jex.im ScrollReveal cross-env sequelize Puppeteer nodemon Django Scrapy 学习 learngitbranching 微信读书 现代 JavaScript 教程 Git仓库 leek-code fishing-fund 其他 wallhaven TinyPNG PicX carbon Rainyscope flatUI …","link":"/2019/04/26/%E8%A3%85%E6%9C%BA%E8%BD%AF%E4%BB%B6/"}],"tags":[],"categories":[{"name":"开发者手册","slug":"开发者手册","link":"/categories/%E5%BC%80%E5%8F%91%E8%80%85%E6%89%8B%E5%86%8C/"},{"name":"JavaScript","slug":"开发者手册/JavaScript","link":"/categories/%E5%BC%80%E5%8F%91%E8%80%85%E6%89%8B%E5%86%8C/JavaScript/"},{"name":"Git","slug":"开发者手册/Git","link":"/categories/%E5%BC%80%E5%8F%91%E8%80%85%E6%89%8B%E5%86%8C/Git/"},{"name":"其他","slug":"开发者手册/其他","link":"/categories/%E5%BC%80%E5%8F%91%E8%80%85%E6%89%8B%E5%86%8C/%E5%85%B6%E4%BB%96/"}]}